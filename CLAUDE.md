# 开发指南

## 交互原则
- 总是使用中文回答
- 小程序代码尽量使用微信小程序原生组件和框架
- 记住我的名字， 我叫余Sir

## 哲学

### 核心信念

- **渐进式改进优于一次性大变动** - 能够编译并通过测试的小改动  
- **从现有代码中学习** - 在实现前先研究并制定计划  
- **务实胜过教条** - 适应项目的实际情况  
- **清晰的意图胜过花哨的代码** - 选择平凡且直观的实现

### 简单意味着

- 每个函数/类只承担单一职责  
- 避免过早抽象  
- 不耍花招 —— 选用乏味但可靠的方案  
- 如果需要额外解释，那就太复杂了

## 流程

### 1. 规划与分阶段

将复杂工作拆成 3–5 个阶段。在 `IMPLEMENTATION_PLAN.md` 中记录：

    
    ```markdown
    ## 阶段 N: [名称]
    **目标**: [具体交付项]
    **成功标准**: [可测试的结果]
    **测试**: [具体测试用例]
    **状态**: [未开始|进行中|完成]
    ```
- 随着进度更新状态  
- 所有阶段完成后删除该文件

### 2. 实现流程

1. **理解** - 学习代码库中现有的模式  
2. **测试** - 先写测试（红灯）  
3. **实现** - 用最少的代码通过测试（绿灯）  
4. **重构** - 在测试通过的前提下清理代码  
5. **提交** - 带上清晰的提交信息并关联到计划

### 3. 卡住时（3 次尝试后）

**重要**：每个问题最多尝试 3 次，然后停止。

1. **记录失败内容**：  
   - 你尝试过什么  
   - 具体的错误信息  
   - 你认为失败的原因

2. **研究替代方案**：  
   - 找到 2–3 个类似的实现  
   - 记录使用了哪些不同的方法

3. **质疑基本假设**：  
   - 这是合适的抽象层次吗？  
   - 能否拆成更小的问题？  
   - 是否存在完全更简单的方法？

4. **换个角度再试**：  
   - 使用不同的库/框架特性？  
   - 采用不同的架构模式？  
   - 不是增加抽象，而是去掉它？

## 技术标准

### 架构原则

- **组合优于继承** - 使用依赖注入  
- **接口优于单例** - 便于测试和提高灵活性  
- **显式优于隐式** - 数据流与依赖要清晰  
- **尽量采用测试驱动** - 绝不要禁用测试，要修复它们

### 代码质量

- **每次提交必须**：  
  - 成功编译  
  - 通过所有现有测试  
  - 为新功能包含测试  
  - 遵循项目的格式化/lint 规范

- **提交前**：  
  - 运行格式化工具/检查器  
  - 自我审查改动  
  - 确保提交信息说明“为什么”要做这些改动

### 错误处理

- 快速失败并提供描述性信息  
- 包含调试所需的上下文  
- 在合适的层级处理错误  
- 绝不悄悄吞掉异常

## 决策框架

当存在多种合理方案时，基于以下原则选择：

1. **可测试性** - 是否容易进行测试？  
2. **可读性** - 半年后别人是否能看懂？  
3. **一致性** - 是否符合项目中的既有模式？  
4. **简单性** - 是否是能够工作的最简单方案？  
5. **可逆性** - 以后修改会有多难？

## 项目集成

### 学习代码库

- 找到 3 个相似的功能/组件  
- 识别常见的模式和约定  
- 尽量使用相同的库/工具  
- 遵循现有的测试模式

### 工具链

- 使用项目已有的构建系统  
- 使用项目的测试框架  
- 使用项目的格式化/lint 设置  
- 未经充分理由不要引入新工具

## 质量关卡

### 完成定义

- [ ] 测试已编写并通过  
- [ ] 代码遵循项目约定  
- [ ] 无格式化/检查器警告  
- [ ] 提交信息清晰  
- [ ] 实现与计划一致  
- [ ] 没有没有关联 issue 编号的 TODO

### 测试指南

- 测试行为，而非具体实现  
- 尽量每个测试只包含一个断言  
- 测试名称要清晰描述场景  
- 使用现有的测试工具/辅助函数  
- 测试应当是确定性的

## 重要提醒

**绝不**：  
- 使用 `--no-verify` 跳过提交钩子  
- 禁用测试而不是修复它们  
- 提交无法编译的代码  
- 做未经验证的假设 —— 要用现有代码确认

**务必**：  
- 以渐进方式提交可运行的代码  
- 随进度更新计划文档  
- 从现有实现中学习  
- 在三次失败后停止并重新评估
